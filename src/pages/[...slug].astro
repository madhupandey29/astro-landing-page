---
// src/pages/[...slug].astro

// @ts-nocheck

import { Fragment } from "astro/jsx-runtime";

import LandingLayout from "../layouts/LandingLayout.astro";
import WhatsAppFab from "../components/WhatsAppFab.astro";
import FashionTestimonial from "../components/sections/Testimonial.astro";
import FAQ from "../components/sections/FAQSection.astro";
import ContactSection from "../components/sections/ContactSection.astro";
import RelatedProductsByLocation from "../components/sections/RelatedProductsByLocation.astro";
import OverviewSection from "../components/sections/OverviewSection.astro";
import StickyContactModal from "../components/StickyContactModal.astro";
import CityProductHero from "../components/sections/CityProductHero.astro";
import ProductHeroBySlug from "../components/sections/ProductHeroBySlug.astro";
import MarketAreaModal from "../components/MarketAreaModal.astro";
import HeadSEO from "../components/HeadSEO.astro";

import { apiGet } from "../lib/api-client";

export const prerender = false;

/* ========= Config ========= */
const DEFAULT_CITY_CODE = "ahmedabad";
/** Fixed default product slug used only for internal non-SEO logic */
const FALLBACK_PRODUCT_SLUG = "silky-denim-55-ozs";

/* ========= Backend env (base + auth) ========= */
const API_BASE_RAW = import.meta.env.PUBLIC_API_BASE_URL || "";
const API_BASE = String(API_BASE_RAW).replace(/\/+$/, "");

const API_KEY = import.meta.env.PUBLIC_API_KEY;
const API_KEY_HEADER = import.meta.env.PUBLIC_API_KEY_HEADER || "x-api-key";
const ADMIN_EMAIL = import.meta.env.PUBLIC_ADMIN_EMAIL;
const ADMIN_EMAIL_HEADER =
  import.meta.env.PUBLIC_ADMIN_EMAIL_HEADER || "x-admin-email";

const authHeaders = (): Record<string, string> => {
  const headers: Record<string, string> = { Accept: "application/json" };
  if (API_KEY) headers[API_KEY_HEADER] = API_KEY;
  if (ADMIN_EMAIL) headers[ADMIN_EMAIL_HEADER] = ADMIN_EMAIL;
  return headers;
};

/* ========= Public GEO API base (can override via env) ========= */
const GEO_API_BASE = import.meta.env.PUBLIC_GEO_API_BASE || "https://ipapi.co";

/* Known city codes (can later come from API) */
const CITY_CODES = [
  "ahmedabad",
  "jaipur",
  "mumbai",
  "delhi",
  "tiruppur",
  "surat",
  "kanpur",
  "kolkata",
  "ludhiana",
  "bhiwandi",
  "ichalkaranji",
  "noida",
  "gurugram",
  "coimbatore",
  "bengaluru",
  "hyderabad",
  "chennai",
  "pune",
  "indore",
  "bhopal",
  "varanasi",
  "solapur",
  "amravati",
  "panipat",
  "nagpur",
  "bhilwara",
  "ranipet",
  "rajkot",
].map((s) => s.toLowerCase());

/* ========= GEO helpers ========= */
type GeoSlugs = {
  countrySlug: string;
  stateSlug: string;
  citySlug: string;
  areaSlug: string;
};

/** Fallback geo (used for localhost / failures) */
const FALLBACK_GEO: GeoSlugs = {
  countrySlug: "india",
  stateSlug: "gujarat",
  citySlug: "ahmedabad",
  areaSlug: "isanpur",
};

/** Convert any text to a clean, lowercase slug for URL path */
const slugifyForPath = (value: string): string => {
  return String(value || "")
    .trim()
    .toLowerCase()
    .replace(/['’]/g, "")
    .replace(/[^a-z0-9]+/g, "-")
    .replace(/^-+|-+$/g, "");
};

/** Resolve GEO from request IP and map to {country,state,city,area} slugs */
const getGeoSlugsFromRequest = async (req: Request): Promise<GeoSlugs | null> => {
  try {
    const xff = req.headers.get("x-forwarded-for") || "";
    const ipCandidate = xff.split(",")[0].trim();
    const ip =
      ipCandidate && ipCandidate !== "127.0.0.1" && ipCandidate !== "::1"
        ? ipCandidate
        : "";

    const url = ip
      ? `${GEO_API_BASE}/${encodeURIComponent(ip)}/json/`
      : `${GEO_API_BASE}/json/`;

    // ✅ GEO API is PUBLIC → do NOT send your backend auth headers here
    const res = await fetch(url, { headers: { Accept: "application/json" } });
    if (!res.ok) return null;

    const data = await res.json();

    const countryName =
      data?.country_name || data?.country || FALLBACK_GEO.countrySlug;
    const stateName =
      data?.region ||
      data?.region_name ||
      data?.state ||
      FALLBACK_GEO.stateSlug;
    const cityName = data?.city || FALLBACK_GEO.citySlug;
    const areaName =
      data?.district ||
      data?.suburb ||
      data?.county ||
      data?.locality ||
      data?.city ||
      FALLBACK_GEO.areaSlug;

    const countrySlug = slugifyForPath(countryName) || FALLBACK_GEO.countrySlug;
    const stateSlug = slugifyForPath(stateName) || FALLBACK_GEO.stateSlug;
    const citySlug = slugifyForPath(cityName) || FALLBACK_GEO.citySlug;
    const areaSlug = slugifyForPath(areaName) || FALLBACK_GEO.areaSlug;

    return { countrySlug, stateSlug, citySlug, areaSlug };
  } catch {
    return null;
  }
};

/* ========= Params / URL schema parsing ========= */
const raw = Astro.params.slug as string | undefined;

// ✅ IMPORTANT FIX:
// /market-area => raw is usually "market-area" (no slash), so endsWith("/market-area") was FALSE before.
const isMarketAreaModalPath =
  raw === "market-area" || (raw ? raw.endsWith("/market-area") : false);

// Remove trailing market-area segment for SEO/Content routing
const rawForRouting = isMarketAreaModalPath
  ? (raw || "").replace(/(?:^|\/)market-area$/, "")
  : raw;

const segments = rawForRouting
  ? String(rawForRouting).split("/").filter(Boolean)
  : [];

const isHomePage = segments.length === 0;

const first = (segments[0] ?? "").toLowerCase();
const second = (segments[1] ?? "").toLowerCase();
const hasInKeyword = second === "in";

// product × location URL pattern:
// /:productSlug/in/:countrySlug?/:stateSlug?/:citySlug?/:locationSlug?
const isProductLocationPage = !isHomePage && hasInKeyword;

/**
 * City landing:
 *   - NOT home
 *   - NOT product×location
 *   - slug is in CITY_CODES
 */
const isCityLanding =
  !isHomePage && !isProductLocationPage && CITY_CODES.includes(first);
const isCityPage = isCityLanding;

/* ========= Request URL ========= */
const reqUrl = new URL(Astro.request.url);

/* ========= GEO-based slugs ========= */
let geo: GeoSlugs | null = await getGeoSlugsFromRequest(Astro.request);
if (!geo) geo = FALLBACK_GEO;

// product slug coming from URL only in /:productSlug/in/...
let productSlugFromUrl = "";
let countrySlug: string | undefined;
let stateSlug: string | undefined;
let citySlug: string | undefined;
let locationSlug: string | undefined;

if (isProductLocationPage) {
  productSlugFromUrl = first; // product slug from URL
  countrySlug = (segments[2] || "").toLowerCase() || undefined;
  stateSlug = (segments[3] || "").toLowerCase() || undefined;
  citySlug = (segments[4] || "").toLowerCase() || undefined;
  locationSlug = (segments[5] || "").toLowerCase() || undefined;
}

// Fill missing parts for product × location URLs using GEO slugs
if (isProductLocationPage && geo) {
  countrySlug = (countrySlug || geo.countrySlug) as string;
  stateSlug = (stateSlug || geo.stateSlug) as string;
  citySlug = (citySlug || geo.citySlug) as string;
  locationSlug = (locationSlug || geo.areaSlug) as string;
}

// For internal non-SEO use only
const slugForGeo = (productSlugFromUrl || FALLBACK_PRODUCT_SLUG).toLowerCase();

/* ========= Current city helper ========= */
const currentCity = isCityLanding
  ? first
  : citySlug || locationSlug || DEFAULT_CITY_CODE;

/* ========= SEO / product-location fetch ========= */
const norm = (s: any) => String(s ?? "").trim().toLowerCase();
type SeoDoc = Record<string, any>;

let seoDoc: SeoDoc | null = null;
let relatedSeoDocs: SeoDoc[] = [];

// Skip SEO calls for pure modal-only path (/market-area*)
if (!isMarketAreaModalPath) {
  try {
    if (isProductLocationPage && slugForGeo) {
      // ✅ Try a dedicated endpoint (if you have it)
      let got = false;

      try {
        const response = await apiGet(`product-location/${encodeURIComponent(slugForGeo)}`);
        if (response.ok) {
          const json = await response.json();
          const data = Array.isArray(json) ? json : Array.isArray(json?.data) ? json.data : [];
          if (data.length) {
            seoDoc = data[0];
            relatedSeoDocs = data.slice(1);
            got = true;
          }
        }
      } catch {
        // ignore and fallback
      }

      // ✅ Fallback to your existing endpoint if dedicated one isn't present
      if (!got) {
        try {
          const response = await apiGet(`productandlocation/astro/products`);
          if (response.ok) {
            const json = await response.json();
            const rows = Array.isArray(json?.data) ? json.data : Array.isArray(json) ? json : [];

            const matched =
              rows.find((row: any) => {
                const rowSlug = norm(row?.slug);
                const productSlug = norm(row?.product?.slug);
                return rowSlug === norm(slugForGeo) || productSlug === norm(slugForGeo);
              }) || rows[0];

            if (matched) {
              seoDoc = matched;
              relatedSeoDocs = rows.filter((r: any) => r !== matched);
            }
          }
        } catch {
          // ignore
        }
      }
    } else {
      // City / generic pages: use backend SEO endpoint with path + GEO info
      const url = new URL(`${API_BASE}/seo`);
      url.searchParams.set("path", reqUrl.pathname.replace(/\/+$/, "") || "/");
      url.searchParams.set("mode", isCityPage ? "city" : "generic");

      if (geo) {
        url.searchParams.set("country", geo.countrySlug);
        url.searchParams.set("state", geo.stateSlug);
        url.searchParams.set("city", geo.citySlug);
        url.searchParams.set("location", geo.areaSlug);
      }

      const response = await apiGet(`seo${url.search}`);
      if (response.ok) {
        const json = await response.json();
        const data: SeoDoc[] = Array.isArray(json?.data)
          ? json.data
          : json?.data
          ? [json.data]
          : [];

        if (data.length) {
          seoDoc = data[0];
          relatedSeoDocs = data.slice(1);
        }
      }
    }
  } catch {
    seoDoc = null;
    relatedSeoDocs = [];
  }
}

/* ========= Product fetch (for title, schema, etc.) ========= */
type ProductDoc = {
  _id?: string;
  slug?: string;
  name?: string;
  productTitle?: string;
  shortProductDescription?: string;
  fullProductDescription?: string;
  salesPrice?: number;
  rating_value?: number;
  rating_count?: number;
  image1?: string;
  image2?: string;
  image3?: string;
  videourl?: string;
};

let productDoc: ProductDoc | null = null;

const extractFirstProduct = (json: any): ProductDoc | null => {
  const data = Array.isArray(json?.data) ? json.data : json?.data ? [json.data] : [];
  return data.length ? (data[0] as ProductDoc) : null;
};

const productSlugFromSeo =
  seoDoc?.product?.slug ? norm(seoDoc.product.slug) : undefined;

const currentSlug =
  productSlugFromSeo ||
  (productSlugFromUrl ? norm(productSlugFromUrl) : "") ||
  (seoDoc?.slug ? norm(seoDoc.slug) : "") ||
  (!isCityPage && segments[0] ? norm(segments[0]) : "");

if (!isMarketAreaModalPath) {
  try {
    // For product × location: if product is already embedded in seoDoc, use it
    if (isProductLocationPage && seoDoc?.product && typeof seoDoc.product === "object") {
      productDoc = seoDoc.product as ProductDoc;
    } else {
      // 1) Try by product ID from SEO document (seoDoc.product = "6931...")
      if (seoDoc?.product && typeof seoDoc.product === "string") {
        try {
          const byIdResponse = await apiGet(`product/${encodeURIComponent(seoDoc.product)}`);
          if (byIdResponse.ok) {
            const json = await byIdResponse.json();
            productDoc = extractFirstProduct(json);
          }
        } catch {
          // ignore
        }
      }

      // 2) Fallback – try by slug
      if (!productDoc && currentSlug) {
        try {
          const bySlugResponse = await apiGet(`product?slug=${encodeURIComponent(currentSlug)}`);
          if (bySlugResponse.ok) {
            const json = await bySlugResponse.json();
            productDoc = extractFirstProduct(json);
          }
        } catch {
          // ignore
        }
      }
    }
  } catch {
    productDoc = null;
  }
}

/* ========= Page-level title/description (layout props) ========= */
const derivedTitleFromData =
  productDoc?.productTitle ||
  productDoc?.name ||
  seoDoc?.productlocationtitle ||
  seoDoc?.meta_og_twitter_title_product_location ||
  seoDoc?.title ||
  "";

const pageTitle =
  derivedTitleFromData && derivedTitleFromData.trim().length
    ? derivedTitleFromData
    : undefined;

const pageDesc =
  (seoDoc?.description ||
    seoDoc?.excerpt ||
    productDoc?.shortProductDescription ||
    "") || undefined;

/**
 * Canonical: use ONLY API value (seoDoc.canonical_url)
 */
const canonical =
  typeof seoDoc?.canonical_url === "string" &&
  seoDoc.canonical_url.trim().length > 0
    ? seoDoc.canonical_url.trim()
    : undefined;

/* ========= Helpers ========= */
function s(v: any) {
  if (v === null || v === undefined) return "";
  if (typeof v === "string") return v;
  if (typeof v === "number" || typeof v === "boolean") return String(v);
  try {
    return JSON.stringify(v);
  } catch {
    return String(v);
  }
}

const stripHtml = (value: string) =>
  value.replace(/<[^>]+>/g, " ").replace(/\s+/g, " ").trim();

const cleanText = (value: any) => {
  const raw2 = s(value);
  if (!raw2) return undefined;
  const cleaned = stripHtml(raw2);
  return cleaned || undefined;
};

const cleanPhone = (value: string) => value.replace(/[^\d+]/g, "");

const asNumber = (v: any) => {
  if (v === null || v === undefined) return undefined;
  const n = Number(v);
  return Number.isFinite(n) ? n : undefined;
};

/* ========= Company info (for JSON-LD) ========= */
type OfficeInfo = {
  companyName?: string;
  companyPhone1?: string;
  companyPhone2?: string;
  whatsappNumber?: string;
  companyEmail?: string;
  companyAddress?: string;
  companyLogoUrl?: string;
};

let officeDoc: OfficeInfo | null = null;

if (!isMarketAreaModalPath) {
  try {
    // ✅ use auth headers
    const res = await fetch(`${API_BASE}/officeinformation`, { headers: authHeaders() });
    if (res.ok) {
      const json = await res.json();
      const data = Array.isArray(json?.data) ? json.data : [];
      officeDoc = data.length ? (data[0] as OfficeInfo) : null;
    }
  } catch {
    officeDoc = null;
  }
}

const company = {
  name: (officeDoc?.companyName ?? "").trim(),
  email: (officeDoc?.companyEmail ?? "").trim(),
  phone:
    (officeDoc?.companyPhone1 ?? "").trim() ||
    (officeDoc?.whatsappNumber ?? "").trim() ||
    (officeDoc?.companyPhone2 ?? "").trim(),
  address: (officeDoc?.companyAddress ?? "").trim(),
  logo: (officeDoc?.companyLogoUrl ?? "").trim(),
};

/* ========= Extra app-level meta values from API ========= */
const xGeoProductUrl =
  (seoDoc?.xGeoProductUrl && String(seoDoc.xGeoProductUrl).trim()) || undefined;

const xProductSlug =
  (seoDoc?.xProductSlug && String(seoDoc.xProductSlug).trim().toLowerCase()) ||
  (productDoc?.slug && String(productDoc.slug).trim().toLowerCase()) ||
  undefined;

/* ========= JSON-LD ========= */
const structuredData = (() => {
  if (isMarketAreaModalPath) return [];

  if (!seoDoc && !company.name) return [];

  const canonicalUrl = seoDoc?.canonical_url || canonical;

  const productName =
    cleanText(productDoc?.productTitle) ||
    cleanText(productDoc?.name) ||
    cleanText(seoDoc?.title) ||
    cleanText(seoDoc?.productlocationtitle);

  const productDescription =
    cleanText(productDoc?.shortProductDescription) ||
    cleanText(seoDoc?.description) ||
    cleanText(seoDoc?.excerpt) ||
    cleanText(seoDoc?.productdescription);

  const productNode: any = productDoc ?? seoDoc?.product ?? null;

  const priceNum = asNumber(productNode?.salesPrice ?? seoDoc?.salesPrice);
  const ratingValueNum = asNumber(productNode?.rating_value ?? seoDoc?.rating_value);
  const ratingCountNum = asNumber(productNode?.rating_count ?? seoDoc?.rating_count);

  const imageUrl =
    seoDoc?.ogImage ||
    productNode?.ogImage_twitterimage ||
    productNode?.image1 ||
    productNode?.image2 ||
    productNode?.image3 ||
    undefined;

  const organizationLd =
    company.name || company.logo || company.email || company.phone
      ? {
          "@context": "https://schema.org",
          "@type": "Organization",
          name: company.name || undefined,
          url: canonicalUrl || undefined,
          logo: company.logo || undefined,
          email: company.email || undefined,
          contactPoint:
            company.phone && company.phone.trim().length
              ? [
                  {
                    "@type": "ContactPoint",
                    telephone: cleanPhone(company.phone),
                    contactType: "customer support",
                    availableLanguage: ["en", "hi"],
                  },
                ]
              : undefined,
          address: company.address
            ? {
                "@type": "PostalAddress",
                streetAddress: stripHtml(company.address),
              }
            : undefined,
        }
      : null;

  const hasProductData = productName || productDescription || imageUrl || priceNum;

  const productLd =
    seoDoc && hasProductData
      ? {
          "@context": "https://schema.org",
          "@type": "Product",
          name: productName || undefined,
          description: productDescription,
          sku: cleanText(seoDoc?.sku),
          mpn: cleanText(seoDoc?.productIdentifier),
          brand: company.name ? { "@type": "Brand", name: company.name } : undefined,
          image: imageUrl ? [String(imageUrl)] : undefined,
          offers:
            priceNum !== undefined
              ? {
                  "@type": "Offer",
                  priceCurrency: "INR",
                  price: priceNum,
                  availability: "https://schema.org/InStock",
                  url: canonicalUrl || undefined,
                }
              : undefined,
          aggregateRating:
            ratingValueNum !== undefined && ratingCountNum !== undefined
              ? {
                  "@type": "AggregateRating",
                  ratingValue: ratingValueNum,
                  reviewCount: ratingCountNum,
                }
              : undefined,
        }
      : null;

  const breadcrumbLd =
    canonicalUrl && (productName || seoDoc?.title)
      ? {
          "@context": "https://schema.org",
          "@type": "BreadcrumbList",
          itemListElement: [
            { "@type": "ListItem", position: 1, name: "Home", item: reqUrl.origin },
            !isCityPage
              ? {
                  "@type": "ListItem",
                  position: 2,
                  name: productName || cleanText(seoDoc?.title),
                  item: canonicalUrl,
                }
              : null,
          ].filter(Boolean),
        }
      : null;

  const localBusinessLd =
    company.name && company.address
      ? {
          "@context": "https://schema.org",
          "@type": "LocalBusiness",
          name: company.name,
          url: canonicalUrl || undefined,
          telephone: company.phone ? cleanPhone(company.phone) : undefined,
          email: company.email || undefined,
          address: {
            "@type": "PostalAddress",
            streetAddress: stripHtml(company.address),
          },
        }
      : null;

  return [organizationLd, productLd, breadcrumbLd, localBusinessLd].filter(Boolean);
})();

const structuredDataJson = structuredData
  .map((node) => {
    const json = JSON.stringify(node, null, 2);
    return json ? json.replace(/<\/script>/gi, "<\\/script>") : "";
  })
  .filter(Boolean);
---

<LandingLayout title={pageTitle} description={pageDesc} canonical={canonical}>
  <Fragment slot="head">
    {/* ✅ IMPORTANT: On /market-area* skip HeadSEO so it won't hit defaultseo/officeinformation (and won't log 401s). */}
    {!isMarketAreaModalPath && <HeadSEO seo={seoDoc} canonical={canonical} />}

    {!isMarketAreaModalPath && xGeoProductUrl && (
      <meta name="x-geo-product-url" content={xGeoProductUrl} />
    )}
    {!isMarketAreaModalPath && xProductSlug && (
      <meta name="x-product-slug" content={xProductSlug} />
    )}

    {!isMarketAreaModalPath &&
      structuredDataJson.map((json) => (
        <script type="application/ld+json" set:html={json} />
      ))}
  </Fragment>

  {/* Keep your existing behavior: market-area route shows just modal-related UI */}
  {isMarketAreaModalPath ? null : (
    <Fragment>
      {isCityPage ? (
        <CityProductHero cityCode={currentCity} />
      ) : (
        <ProductHeroBySlug
          currentSlug={currentSlug}
          seoDoc={seoDoc}
          productFromSeo={seoDoc?.product}
        />
      )}

      {isCityPage ? (
        <OverviewSection currentSlug={currentSlug} />
      ) : (
        <OverviewSection currentSlug={currentSlug} />
      )}

      {isCityPage ? (
        <RelatedProductsByLocation
          cityCode={currentCity}
          seoDoc={seoDoc}
          products={relatedSeoDocs}
          title="Explore Our Fabric Catalog"
          subtitle="City-specific products curated for your sourcing"
        />
      ) : (
        <RelatedProductsByLocation
          currentSlug={currentSlug}
          seoDoc={seoDoc}
          products={relatedSeoDocs}
          title="Explore Our Fabric Catalog"
          subtitle="More options from this location"
        />
      )}
    </Fragment>
  )}

  <StickyContactModal
    side="left"
    targetId="contact"
    offsetBottom="max(env(safe-area-inset-bottom),16px)"
    label="Get Your Free Sample Today"
  />

  <WhatsAppFab />

  <FashionTestimonial
    locationName={
      seoDoc?.location?.name ||
      (currentCity && currentCity.charAt(0).toUpperCase() + currentCity.slice(1))
    }
  />

  <FAQ />
  <ContactSection />
  <MarketAreaModal />
</LandingLayout>
